
ï»¿using Microsoft.Win32;
using NAudio.Wave;
using System;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Text;
using System.Windows;

namespace P4G_PC_Music_Converter
{
    /// <summary>
    /// Interaction logic for MainWindow.xaml
    /// </summary>
    public partial class MainWindow : Window
    {
        private const string AdpcmEncoderPath = "tools/AdpcmEncode.exe";

        public MainWindow()
        {
            InitializeComponent();
        }

        private void ConvertButton_Click(object sender, RoutedEventArgs e)
        {
            // Check to ensure all the necessary fields are filled out before we proceed
            bool fieldsPopulated = !string.IsNullOrWhiteSpace(InputWavPath.Text) &&
                !string.IsNullOrWhiteSpace(OutputRawPath.Text) &&
                (!LoopEnable.IsChecked.Value || (!string.IsNullOrWhiteSpace(LoopStart.Text)) && !string.IsNullOrWhiteSpace(LoopEnd.Text));

            if (!fieldsPopulated)
            {
                MessageBox.Show("Not all required fields have been filled out!\n" +
                    "Make sure that both input and output file paths are specified,\n" +
                    "and if looping is enabled, make sure the start and end point are provided.");
                return;
            }

            // Verify that the input file exists
            if (!File.Exists(InputWavPath.Text))
            {
                MessageBox.Show("The specified input file does not exist!");
                return;
            }

            // If looping is enabled, ensure that the loop start and end textboxes contain valid numbers
            if (LoopEnable.IsChecked.Value)
            {
                if (!int.TryParse(LoopStart.Text, NumberStyles.Integer, CultureInfo.CurrentCulture, out int _) ||
                    int.Parse(LoopStart.Text, NumberStyles.Integer) < 0)
                {
                    MessageBox.Show("Unable to parse the loop start point, make sure it's a valid positive integer!");
                    return;
                }

                if (!int.TryParse(LoopEnd.Text, NumberStyles.Integer, CultureInfo.CurrentCulture, out int _) ||
                    int.Parse(LoopEnd.Text, NumberStyles.Integer) < 0)
                {
                    MessageBox.Show("Unable to parse the loop end point, make sure it's a valid positive integer!");
                    return;
                }
            }

            string encodedInputPath;
            if (!EncodingPassthrough.IsChecked.Value)
            {
                encodedInputPath = OutputRawPath.Text;

                // Encode the input file using the MSADPCM tool
                if (!File.Exists(AdpcmEncoderPath))
                {
                    MessageBox.Show($"Unable to find MSADPCM encoder tool! It should be located in {AdpcmEncoderPath}");
                    return;
                }

                ProcessStartInfo startInfo = new ProcessStartInfo(AdpcmEncoderPath, $"\"{InputWavPath.Text}\" \"{OutputRawPath.Text}\"");
                var encodeProcess = Process.Start(startInfo);
                encodeProcess.WaitForExit();
                int exit = encodeProcess.ExitCode;

                if (exit != 0)
                {
                    MessageBox.Show($"The MSADPCM encoder tool exited with code {exit}. This indicates an error. Aborting...");
                    return;
                }
            }
            else
            {
                encodedInputPath = InputWavPath.Text;
            }

            // Read the input file and determine/verify its info (sample count, etc.)
            byte[] dataSegment;
            using (WaveFileReader waveReader = new WaveFileReader(encodedInputPath))
            {
                // Store the data segment (what ends up in the final RAW file) in a byte array temporarily
                dataSegment = new byte[waveReader.Length];
                waveReader.Read(dataSegment, 0, (int)waveReader.Length);

                // Create a StringBuilder to output the info about this file to our TextBlock
                StringBuilder outputInfoBuilder = new StringBuilder();

                // We can't get the sample count from the ADPCM encoded wave, so we need to use the original input file
                long sampleCount = -1;
                using (WaveFileReader originalWaveReader = new WaveFileReader(InputWavPath.Text))
                {
                    sampleCount = originalWaveReader.SampleCount;
                }

                outputInfoBuilder.Append($"num_samples = {sampleCount}\n");

                string encodingString;
                if (waveReader.WaveFormat.Encoding.ToString().ToUpperInvariant() == "ADPCM")
                {
                    encodingString = "MSADPCM";
                }
                else if (waveReader.WaveFormat.Encoding.ToString().ToUpperInvariant() == "PCM")
                {
                    encodingString = waveReader.WaveFormat.Encoding.ToString().ToUpperInvariant() + waveReader.WaveFormat.BitsPerSample.ToString();
                    if (waveReader.WaveFormat.BitsPerSample == 16)
                    {
                        encodingString += "LE";